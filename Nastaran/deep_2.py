# -*- coding: utf-8 -*-
"""Deep 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ICp4n4quL_ZBWlWihCL9IINgFefRzk-0
"""

import numpy as np

"""# part 1-1"""

X = np.random.rand(10,3)
Y = np.random.rand(3)
X + Y

X[np.newaxis, :] + Y

X + Y[: , np.newaxis]

X[:, np.newaxis] + Y

X + Y[np.newaxis, :]

X[:, np.newaxis, :] + Y

"""# part 1-2"""

x, y = np.mgrid[:10, :5] 
z=x+y
print(z.shape)

x, y = np.ogrid[:10, :5]
z=x+y
print(z.shape)

"""# part 1-3

One advantage of using np.ogrid over np.mgrid is that np.ogrid creates broadcastable arrays, which can save memory and computational time when working with large arrays.
In particular, np.ogrid creates arrays with only one element along each dimension, but with a size equal to the size of the output array in that dimension. This allows NumPy to avoid creating the entire intermediate array that np.mgrid creates when creating the full arrays.

# part 1-4
"""

import matplotlib.pyplot as plt

city_names = ['City 1', 'City 2', 'City 3', 'City 4', 'City 5', 'City 6', 'City 7', 'City 8', 'City 9', 'City 10']
distances = np.array([0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448])

n_cities = len(city_names)
distance_matrix = np.zeros((n_cities, n_cities))
for i in range(n_cities):
    for j in range(n_cities):
        distance_matrix[i, j] = abs(distances[i] - distances[j])

fig, ax = plt.subplots(figsize=(10, 10))

im = ax.imshow(distance_matrix, cmap='jet')

cbar = ax.figure.colorbar(im, ax=ax)

ax.set_xticks(np.arange(n_cities))
ax.set_yticks(np.arange(n_cities))
ax.set_xticklabels(city_names)
ax.set_yticklabels(city_names)

ax.set_xlabel('Destination city')
ax.set_ylabel('Starting city')
ax.set_title('Distance between cities')

for i in range(n_cities):
    for j in range(n_cities):
        text = ax.text(j, i, distance_matrix[i, j],
                       ha='center', va='center', color='w')

plt.show()

"""# part 1-5"""

import copy

T = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
Q = copy.deepcopy(T)

T[1][0] = 100000

print("T = ", T)
print("Q = ", Q)

"""# part 1-6"""

X = np.array([5, 9, 77, 0, 74, 55, 81, 79, 90])
Y = np.array([5, 1, 46, 2, 10, 29, 55, 4, 90])

mask = X > Y
indices = np.where(mask)[0]
elements = X[mask]

print("Indices where X > Y:", indices)
print("Elements in X where X > Y:", elements)

X = np.array([5, 9, 77, 0, 74, 55, 81, 79, 90])
Y = np.array([5, 1, 46, 2, 10, 29, 55, 4, 90])

indices = np.where(X == Y)[0]

print("Indices where X == Y:", indices)

"""# part 2-1"""

import torch
from torchvision import datasets, transforms

batch_size = 10
mnist_dataset = datasets.MNIST(root='./data', train=True, transform=transforms.ToTensor(), download=False)

data_loader = torch.utils.data.DataLoader(mnist_dataset, batch_size=batch_size, shuffle=True)

for images, _ in data_loader:
    flattened_images = images.view(batch_size, -1)
    print(flattened_images.shape)
    break

train_dataset = datasets.MNIST(root='./data', train=True, download=False)
test_dataset = datasets.MNIST(root='./data', train=False, download=False)

# Plot the first 5 numbers in the dataset
fig, axs = plt.subplots(1, 5, figsize=(15, 3))
for i in range(5):
    axs[i].imshow(train_dataset[i][0], cmap='gray')
    axs[i].set_title(f"Label: {train_dataset[i][1]}")
    axs[i].axis('off')
plt.show()

# Rotate the third number counterclockwise
img = train_dataset[2][0]
img = np.flip(np.transpose(img, (1, 0)), axis=0)

# Plot the rotated image
plt.imshow(img, cmap='gray')
plt.title(f"Label: {train_dataset[2][1]}")
plt.axis('off')
plt.show()

# Create a batch of MNIST digits
batch_size = 10
batch = torch.stack([train_dataset[i][0] for i in range(batch_size)], dim=0)

# Flatten the batch to a single vector
flat_batch = batch.view(batch_size, -1)

fig, axs = plt.subplots(batch_size, 1, figsize=(2, 10))
for i in range(batch_size):
    axs[i].imshow(batch[i], cmap='gray')
    axs[i].set_title(f"Label: {train_dataset[i][1]}")
    axs[i].axis('off')
plt.show()

fig, axs = plt.subplots(1, batch_size, figsize=(10, 2))
for i in range(batch_size):
    axs[i].imshow(batch[i], cmap='gray')
    axs[i].set_title(f"Label: {train_dataset[i][1]}")
    axs[i].axis('off')
plt.show()

batch1 = batch[:batch_size//2]
batch2 = batch[batch_size//2:]

if batch_size % 2 != 0:
    batch2 = torch.cat([batch2, torch.zeros_like(batch[0]).unsqueeze(0)], dim=0)

fig, axs = plt.subplots(2, batch_size//2, figsize=(10, 4))
for i in range(batch_size//2):
    axs[0, i].imshow(batch1[i], cmap='gray')
    axs[0, i].set_title

"""# part 2-2"""

from mpl_toolkits.mplot3d import Axes3D
from torchvision import datasets
import torchvision
import random

train_data = datasets.MNIST(root='./data', train=True, download=False)

train_data.data = (train_data.data.float() / 255.0)

mean_per_sample = torch.mean(train_data.data.view(train_data.data.shape[0], -1), dim=1)
plt.hist(mean_per_sample.numpy(), bins=20)
plt.xlabel('Mean Pixel Value')
plt.ylabel('Count')
plt.title('Distribution of Mean Pixel Values')
plt.show()

mnist_dataset = torchvision.datasets.MNIST(root='data/', train=True, transform=torchvision.transforms.ToTensor(),download=False)
sample_index = random.randint(0, len(mnist_dataset) - 1)
sample = mnist_dataset[sample_index]
image = sample[0].numpy()
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = np.linspace(0, 27, 28)
y = np.linspace(0, 27, 28)
X, Y = np.meshgrid(x, y)
Z = image[0, :, :]
ax.plot_surface(X, Y, Z, cmap='RdYlBu')
plt.show()

mnist_train = datasets.MNIST(root="./data", train=False, download=False)
labels = mnist_train.targets.numpy()
sort_indices = np.argsort(labels)

sorted_mnist_train = datasets.MNIST(root="./data", train=False, download=False)
sorted_mnist_train.data = sorted_mnist_train.data[sort_indices]
sorted_mnist_train.targets = sorted_mnist_train.targets[sort_indices]

from matplotlib import pyplot as plt

mnist_train = datasets.MNIST(root="./data", train=False, download=False)
labels = mnist_train.targets.numpy()
fig, axs = plt.subplots(2, 5)
for i in range(10):
    axs[i//5, i%5].hist(mnist_train.data[labels == i].numpy().flatten(), bins=10)
    axs[i//5, i%5].set_title(str(i))
    axs[i//5, i%5].set_xlim(0, 255)
plt.show()

"""# part 3

List:
Used in JSON format
Useful for Array operations
Used in Databases

Tuple:
Used to insert records in the database through SQL query at a time.Ex: (1.’sravan’, 34).(2.’geek’, 35)
Used in parentheses checker

Set:
Finding unique elements
Join operations

Dictionary:
Used to create a data frame with lists
Used in JSON

Single-responsibility principle(SRP)
"""

class sat:
    def get_mean(self,numbers):
      me=sum(numbers) / len(numbers)
      print(f"the mean is {me}") 

    def get_max(self,numbers):
      max_num = numbers[0]
      for num in numbers:
          if num > max_num:
              max_num = num
      print(f"the max is {max_num}")
    def log_error(self, error):
        print("log:", error)
    def cacul(self, numbers):
        try:
            self.get_mean(numbers)
            self.get_max(numbers)
        except Exception:
            self.log_error("error in caculation")

if __name__ == '__main__':
    sat = sat()
    arr=[1,2,3,4,5]
    sat.cacul(arr)

"""Introduction to the open-closed principle"""

class phone:
    def __init__(self, name, price):
        self.name = name
        self.price = price    

    def buy(self, cash):
        if cash == self.price:
            print("Buying {}".format(self.name))
        else:
            print("Sorry, you don't have enough money")

    def buy_with_discount(self, cash):
        if int(0.8*self.price) == int(cash):
            print("Buying {} with 20% discount".format(self.name))

if __name__ == '__main__':
    phone = phone('iphone', 1000)
    phone.buy(800)
    phone.buy_with_discount(800)