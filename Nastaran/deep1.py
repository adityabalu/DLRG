# -*- coding: utf-8 -*-
"""deep1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/153KB7NLb7DiL88TKLEP1EJxZyVr-2SbF
"""

# Mount your local google drive
from google.colab import drive
drive.mount('/content/gdrive')

def gen_strobogrammatic(n):
    """
    :type n: int
    :rtype: List[str]
    """
    result = helper(n, n)
    return result


def helper(n, length):
    if n == 0:
        return [""]
    if n == 1:
        return ["1", "0", "8"]
    middles = helper(n-2, length)
    result = []
    for middle in middles:
        if n != length:
            result.append("0" + middle + "0")
        result.append("8" + middle + "8")
        result.append("1" + middle + "1")
        result.append("9" + middle + "6")
        result.append("6" + middle + "9")
    return result

print("n = 2: \n",gen_strobogrammatic(2))
print("n = 3: \n",gen_strobogrammatic(3))
print("n = 4: \n",gen_strobogrammatic(4))

def concat_lower_case(list1, list2):
    result = []
    for string1, string2 in zip(list1, list2):
        concat_string = string1.lower() + " " + string2.lower()
        result.append(concat_string)
    return result
list1 = ['HellO', 'BYe']
list2 = ['woRlD', 'WOrld']
result = concat_lower_case(list1, list2)
print(result)

def multiply_lists(list1, list2):
    result = []
    for x, y in zip(list1, list2):
        if x.isnumeric() and str(y).isnumeric():
            result.append(int(x) * int(y))
    return result
list1 = ['12', '13', 'Hello', '4', '6', '10]'] 
list2 =  ['2', '3', '4', 5, '[6', 12,14]
result = multiply_lists(list1, list2)
print(result)

def get_chapter_numbers(n):
    chapter_numbers = [f"Chapter {i}" for i in range(1, n+1)]
    return chapter_numbers
n = 3
chapter_numbers = get_chapter_numbers(n)
print(chapter_numbers)

class TetrahedralMesh:
    def __init__(self, nodes, connectivity):
        self.nodes = nodes
        self.connectivity = connectivity
        
    def get_node(self, index):
        return self.nodes[index]
    
    def set_node(self, index, node):
        self.nodes[index] = node
        
    def get_element(self, index):
        return self.connectivity[index]
    
    def set_element(self, index, element):
        self.connectivity[index] = element
        
    def get_num_nodes(self):
        return len(self.nodes)
    
    def get_num_elements(self):
        return len(self.connectivity)

def read_mesh_file(filename):
    nodes = []
    connectivity = []

    with open(filename, 'r') as file:
        lines = file.readlines()
        for line in file:
          if line.startswith('/com'):
            continue
          num_nodes = int(lines[0])
          for i in range(1, num_nodes+1):
              node = tuple(map(float, lines[i].split()))
              nodes.append(node)

          num_elements = int(lines[num_nodes+1])
          for i in range(num_nodes+2, num_nodes+num_elements+2):
              element = tuple(map(int, lines[i].split()))
              connectivity.append(element)

    return nodes, connectivity
filename = '/content/gdrive/MyDrive/mesh.dat'
nodes, connectivity = read_mesh_file(filename)
print(connectivity)
mesh = TetrahedralMesh(nodes, connectivity)

import pandas as pd
url="https://www.dropbox.com/s/pavpg172ot4qmbj/mesh.dat?dl=1"
# Read the contents of the .dat file without header names
df = pd.read_csv(url, sep='\t', header=None)

# Display the data frame
print(df)

import time

def timeit(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Time taken for execution of {func.__name__}: {end_time - start_time:.6f} seconds")
        return result
    return wrapper

@timeit
def method1(list1, list2):
    # using for loops with zip iterator
    result = []
    for x, y in zip(list1, list2):
        result.append(x * y)
    return result

@timeit
def method2(list1, list2):
    # using for loops with accessing each member individually
    result = []
    for i in range(len(list1)):
        result.append(list1[i] * list2[i])
    return result

@timeit
def method3(list1, list2):
    # using list comprehensions
    return [x * y for x, y in zip(list1, list2)]

import random

list1 = [random.randint(1, 10) for _ in range(1000)]
list2 = [random.randint(1, 10) for _ in range(1000)]

result1 = method1(list1, list2)
result2 = method2(list1, list2)
result3 = method3(list1, list2)

@timeit
def read_mesh_file(filename):
    nodes = []
    edges = []

    with open(filename) as f:
        for line in f:
            if line.startswith("v "):
                nodes.append([float(x) for x in line.split()[1:]])
            elif line.startswith("l "):
                edges.append([int(x) for x in line.split()[1:]])

    return nodes, edges

nodes, edges = read_mesh_file("/content/gdrive/MyDrive/mesh.dat")

import random

@timeit
def create_random_list(n):
    return [random.uniform(0, 1) for _ in range(n)]

# Create a list of 10,000 random numbers and time it
random_list = create_random_list(10000)

import random

@timeit
def create_random_tuple(n):
    return tuple(random.uniform(0, 1) for _ in range(n))

# Create a tuple of 10,000 random numbers and time it
random_tuple = create_random_tuple(10000)

import numpy as np

# Create a list with 10,000 random elements
random_list = [np.random.uniform(0, 1) for _ in range(10000)]

# Create a tuple with 10,000 random elements
random_tuple = tuple(np.random.uniform(0, 1) for _ in range(10000))

@timeit
def find_median_list():
    return np.median(random_list)

@timeit
def find_median_tuple():
    return np.median(random_tuple)

# Find the median element in each data structure and time the indexing speed
median_list = find_median_list()
median_tuple = find_median_tuple()

def time_kl_divergence():
    """
    Time the kl_divergence method using the @timeit decorator.
    """
    @timeit
    def kl_divergence(p, q):
        """
        Compute the KL-divergence between two normal distributions with means p and q.
        """
        return np.linalg.norm(p - q)

    # generate two normal distributions
    p = np.random.normal(loc=0, scale=1, size=1000)
    q = np.random.normal(loc=1, scale=1, size=1000)

    # compute KL-divergence and time it
    kl_div = kl_divergence(p, q)
    print(f"KL-divergence between p and q: {kl_div:.3f}")

# example usage
time_kl_divergence()

import math

class Robot:
    def __init__(self):
        self.position = [0, 0]
        self.direction = [1, 0]
        self.time = 0.0
        self.speed = 0.5
        
    def __repr__(self):
        return f"Current Position: {self.position}, Current Direction: {self.direction}, Current Time: {self.time}"
    
    def wait(self, time):
        self.time += time
        
    def move_forward(self, time):
        self.time += time
        distance = self.speed * time
        self.position = [self.position[0] + distance * self.direction[0], 
                         self.position[1] + distance * self.direction[1]]
        
    def rotate_right(self):
        self.direction = [self.direction[1], -self.direction[0]]
        
    def rotate_left(self):
        self.direction = [-self.direction[1], self.direction[0]]
robot = Robot()
print(robot)
robot.move_forward(1)
print(robot)

robot.rotate_right()
robot.move_forward(1)
print(robot)

robot.rotate_left()
robot.move_forward(1)
print(robot)

robot.rotate_right()
robot.move_forward(1)

print(robot)

def move_square(side_length):
    robot = Robot()
    print(robot)

    robot.move_forward(side_length)
    print(robot)

    robot.rotate_left()
    robot.move_forward(side_length)
    print(robot)

    robot.rotate_left()
    robot.move_forward(side_length)
    print(robot)

    robot.rotate_left()
    robot.move_forward(side_length)
    print(robot)

move_square(10)